import "vmm.mh";
import "pmm.mh";
import "mm.mh";
import "../libc/std.mh";

var VmmKernelPM: *PageMap;
var VmmCurrentPM: *PageMap;

var [extern] LimineKeAddr: *LimineKeAddrResponse;

var [extern] TextStartLD: char[1];
var [extern] TextEndLD: char[1];

var [extern] RodataStartLD: char[1];
var [extern] RodataEndLD: char[1];

var [extern] DataStartLD: char[1];
var [extern] DataEndLD: char[1];

fn VmmInit(): void {
  VmmKernelPM = <*PageMap>HHalf(PmmAlloc(1));
  memset(VmmKernelPM, 0, GetPgSize());

  VmmKernelPM.TopLvl = <*u64>HHalf(PmmAlloc(1));
  memset(VmmKernelPM.TopLvl, 0, GetPgSize());

  VmmKernelPM.VmaHead = <*VmaRegion>HHalf(PmmAlloc(1));
  memset(VmmKernelPM.VmaHead, 0, GetPgSize());

  VmmKernelPM.VmaHead.Next = VmmKernelPM.VmaHead;
  VmmKernelPM.VmaHead.Prev = VmmKernelPM.VmaHead;

  var PhysBase: u64 = LimineKeAddr.PhysBase;
  var VirtBase: u64 = LimineKeAddr.VirtBase;

  var TextStart: u64 = AlignDown(<u64>TextStartLD, GetPgSize());
  var TextEnd: u64 = AlignUp(<u64>TextEndLD, GetPgSize());

  var RodataStart: u64 = AlignDown(<u64>RodataStartLD, GetPgSize());
  var RodataEnd: u64 = AlignUp(<u64>RodataEndLD, GetPgSize());

  var DataStart: u64 = AlignDown(<u64>DataStartLD, GetPgSize());
  var DataEnd: u64 = AlignUp(<u64>DataEndLD, GetPgSize());

  for (var Text: u64 = TextStart; Text < TextEnd; Text += GetPgSize()) {
    VmmMap(VmmKernelPM, Text, Text - VirtBase + PhysBase, 1);
  }
  for (var Rodata: u64 = RodataStart; Rodata < RodataEnd; Rodata += GetPgSize()) {
    VmmMap(VmmKernelPM, Rodata, Rodata - VirtBase + PhysBase, 1 | (1 << 63));
  }
  for (var Data: u64 = DataStart; Data < DataEnd; Data += GetPgSize()) {
    VmmMap(VmmKernelPM, Data, Data - VirtBase + PhysBase, 1 | 2 | (1 << 63));
  }
  for (var Gb4: u64 = 0; Gb4 < 0x100000000; Gb4 += GetPgSize()) {
    VmmMap(VmmKernelPM, Gb4, Gb4, 1 | 2);
    VmmMap(VmmKernelPM, <u64>HHalf(Gb4), Gb4, 1 | 2);
  }
  VmmSwitchPM(VmmKernelPM);
  printf("VMM Initialised.\n");
}

fn WriteCR3(var Val: u64): void;

fn VmmSwitchPM(var PM: *PageMap): void {
  VmmCurrentPM = PM;
  WriteCR3(<u64>LHalf(PM.TopLvl));
}

fn VmmNewPM(): *PageMap {
  var PM: *PageMap = <*PageMap>HHalf(PmmAlloc(1));
  memset(PM, 0, GetPgSize());
  PM.TopLvl = <*u64>HHalf(PmmAlloc(1));
  memset(PM.TopLvl, 0, GetPgSize());
  for (var i: int = 256; i < 512; i += 1) {
    PM.TopLvl[i] = VmmKernelPM.TopLvl[i];
  }
  ret PM;
}

fn VmmGetFlags(var Present: u8, var Writable: u8, var User: u8, var NX: u8): u64 {
  var Flags: u64 = 0;
  if (Present) Flags |= 1;
  if (Writable) Flags |= 2;
  if (User) Flags |= 4;
  if (NX) Flags |= (1 << 63);
  ret Flags;
}

fn PteGetAddr(var Value: u64): u64 {
  ret Value & 0x000ffffffffff000;
}

fn PteGetFlags(var Value: u64): u64 {
  ret Value & ~0x000ffffffffff000;
}

fn VmmGetNextLvl(var Level: *u64, var Entry: u64): *u64 {
  if (Level[Entry] & 1) ret HHalf(PteGetAddr(Level[Entry]));
  var PML: *u64 = HHalf(PmmAlloc(1));
  memset(PML, 0, GetPgSize());
  Level[Entry] = <u64>LHalf(PML) | 1 | 2 | 3;
  ret PML;
}

fn VmmMap(var PM: *PageMap, var VAddr: u64, var PAddr: u64, var Flags: u64): void {
  var PML1Entry: u64 = (VAddr >> 12) & 0x1ff;
  var PML2Entry: u64 = (VAddr >> 21) & 0x1ff;
  var PML3Entry: u64 = (VAddr >> 30) & 0x1ff;
  var PML4Entry: u64 = (VAddr >> 39) & 0x1ff;

  var PML3: *u64 = VmmGetNextLvl(PM.TopLvl, PML4Entry);
  var PML2: *u64 = VmmGetNextLvl(PML3, PML3Entry);
  var PML1: *u64 = VmmGetNextLvl(PML2, PML2Entry);

  PML1[PML1Entry] = PAddr | Flags;
}

fn VmmGetKePM(): *PageMap {
  ret VmmKernelPM;
}

fn VmmGetPM(): *PageMap {
  ret VmmCurrentPM;
}

fn VmmCreateRegion(var PM: *PageMap, var VAddr: u64, var PAddr: u64,
  var Pages: u64, var Flags: u64): *VmaRegion {
  var Region: *VmaRegion = <*VmaRegion>HHalf(PmmAlloc(1));
  Region.VAddr = VAddr;
  Region.End = VAddr + (Pages * GetPgSize());
  Region.PAddr = PAddr;
  Region.Pages = Pages;
  Region.Flags = Flags;
  Region.RefCnt = 0;
  Region.Next = PM.VmaHead;
  Region.Prev = PM.VmaHead.Prev;
  PM.VmaHead.Prev.Next = Region;
  PM.VmaHead.Prev = Region;
}

fn VmmInsertAfterRegion(var Prev: *VmaRegion, var VAddr: u64, var PAddr: u64,
  var Pages: u64, var Flags: u64): *VmaRegion {
  var Region: *VmaRegion = <*VmaRegion>HHalf(PmmAlloc(1));
  Region.VAddr = VAddr;
  Region.End = VAddr + (Pages * GetPgSize());
  Region.PAddr = PAddr;
  Region.Pages = Pages;
  Region.Flags = Flags;
  Region.RefCnt = 0;
  Region.Next = Prev.Next;
  Region.Prev = Prev;
  Prev.Next.Prev = Region;
  Prev.Next = Region;
  ret Region;
}

fn VmmDeleteRegion(var Region: *VmaRegion): void {
  Region.Prev.Next = Region.Next;
  Region.Next.Prev = Region.Prev;
  PmmFree(LHalf(Region), 1);
}

fn VmmGetRegion(var PM: *PageMap, var VAddr: u64): *VmaRegion {
  for (var Region: *VmaRegion = PM.VmaHead.Next; Region != PM.VmaHead; Region = Region.Next) {
    if (Region.VAddr == VAddr)
      ret Region;
  }
  ret <*VmaRegion>0;
}

fn VmmAlloc(var PM: *PageMap, var Pages: u64, var Flags: u64): *u8 {
  var Page: *u8 = PmmAlloc(Pages);
  if (!Page) ret <*u8>0;
  var VAddr: u64 = PM.VmaHead.Prev.End + GetPgSize();
  var Found: int = 0;
  var Region: *VmaRegion;
  for (Region = PM.VmaHead.Next; Region != PM.VmaHead; Region = Region.Next) {
    if (Region.Next.VAddr - Region.End >= ((Pages + 1) * GetPgSize())) {
      VAddr = Region.End + GetPgSize();
      Region = VmmInsertAfterRegion(Region, VAddr, <u64>Page, Pages, Flags);
      Found = 1;
      break;
    }
  }
  if (!Found) Region = VmmCreateRegion(PM, VAddr, <u64>Page, Pages, Flags);
  for (var i: u64 = 0; i < Pages; i += 1)
    VmmMap(PM, VAddr + (i * GetPgSize()), <u64>Page + (i * GetPgSize()), Flags);
  Region.RefCnt += 1;
  ret <*u8>VAddr;
}

// TODO: VmmFree() Function